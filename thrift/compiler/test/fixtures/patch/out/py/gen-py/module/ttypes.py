#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.lib.thrift.patch.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass

def __EXPAND_THRIFT_SPEC(spec):
    next_id = 0
    for item in spec:
        if next_id >= 0 and item[0] < 0:
            next_id = item[0]
        if item[0] != next_id:
            for _ in range(next_id, item[0]):
                yield None
        yield item
        next_id = item[0] + 1

class ThriftEnumWrapper(int):
  def __new__(cls, enum_class, value):
    return super().__new__(cls, value)
  def __init__(self, enum_class, value):    self.enum_class = enum_class
  def __repr__(self):
    return self.enum_class.__name__ + '.' + self.enum_class._VALUES_TO_NAMES[self]

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyData', 'MyDataWithCustomDefault', 'InnerUnion', 'MyUnion', 'MyStruct', 'LateDefStruct', 'Recursive', 'Bar', 'Loop', 'RefFields']

class MyEnum:
  MyValue0 = 0

  _VALUES_TO_NAMES = {
    0: "MyValue0",
  }

  _NAMES_TO_VALUES = {
    "MyValue0": 0,
  }

class MyData:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyData')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyData, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyData, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefault:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefault')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class InnerUnion(object):
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INNEROPTION = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_innerOption(self):
    assert self.field == 1
    return self.value

  def set_innerOption(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('innerOption', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_innerOption = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_innerOption(_fbthrift_innerOption)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('InnerUnion')
    if self.field == 1:
      oprot.writeFieldBegin('innerOption', TType.STRING, 1)
      innerOption = self.value
      oprot.writeString(innerOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'innerOption' in obj:
      _fbthrift_innerOption = obj['innerOption']
      self.set_innerOption(_fbthrift_innerOption)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnion, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  OPTION1 = 1
  OPTION2 = 2
  OPTION3 = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_option1(self):
    assert self.field == 1
    return self.value

  def get_option2(self):
    assert self.field == 2
    return self.value

  def get_option3(self):
    assert self.field == 3
    return self.value

  def set_option1(self, value):
    self.field = 1
    self.value = value

  def set_option2(self, value):
    self.field = 2
    self.value = value

  def set_option3(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option1', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option2', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option3', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_option1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_option1(_fbthrift_option1)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_option2 = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_option2(_fbthrift_option2)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_option3 = InnerUnion()
          _fbthrift_option3.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_option3(_fbthrift_option3)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('option1', TType.STRING, 1)
      option1 = self.value
      oprot.writeString(option1.encode('utf-8')) if UTF8STRINGS and not isinstance(option1, bytes) else oprot.writeString(option1)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('option2', TType.I32, 2)
      option2 = self.value
      oprot.writeI32(option2)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      option3 = self.value
      option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'option1' in obj:
      _fbthrift_option1 = obj['option1']
      self.set_option1(_fbthrift_option1)
    if 'option2' in obj:
      _fbthrift_option2 = obj['option2']
      if _fbthrift_option2 > 0x7fffffff or _fbthrift_option2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_option2(_fbthrift_option2)
    if 'option3' in obj:
      _fbthrift_option3 = InnerUnion()
      _fbthrift_option3.readFromJson(obj['option3'], is_text=False, **kwargs)
      self.set_option3(_fbthrift_option3)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - enumVal
   - structVal
   - unionVal
   - lateStructVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optEnumVal
   - optStructVal
   - optLateStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - listMap
   - mapMap
   - i32WithCustomDefault
   - structWithCustomDefault
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.optListVal.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.optListVal.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in range(_size23):
              _elem28 = {}
              (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
              if _size29 >= 0:
                for _i33 in range(_size29):
                  _key34 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val35 = iprot.readI32()
                  _elem28[_key34] = _val35
              else: 
                while iprot.peekMap():
                  _key36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37 = iprot.readI32()
                  _elem28[_key36] = _val37
              iprot.readMapEnd()
              self.listMap.append(_elem28)
          else: 
            while iprot.peekList():
              _elem38 = {}
              (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
              if _size39 >= 0:
                for _i43 in range(_size39):
                  _key44 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val45 = iprot.readI32()
                  _elem38[_key44] = _val45
              else: 
                while iprot.peekMap():
                  _key46 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val47 = iprot.readI32()
                  _elem38[_key46] = _val47
              iprot.readMapEnd()
              self.listMap.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = {}
              (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin() 
              if _size55 >= 0:
                for _i59 in range(_size55):
                  _key60 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val61 = iprot.readI32()
                  _val54[_key60] = _val61
              else: 
                while iprot.peekMap():
                  _key62 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val63 = iprot.readI32()
                  _val54[_key62] = _val63
              iprot.readMapEnd()
              self.mapMap[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key64 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val65 = {}
              (_ktype67, _vtype68, _size66 ) = iprot.readMapBegin() 
              if _size66 >= 0:
                for _i70 in range(_size66):
                  _key71 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val72 = iprot.readI32()
                  _val65[_key71] = _val72
              else: 
                while iprot.peekMap():
                  _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val74 = iprot.readI32()
                  _val65[_key73] = _val74
              iprot.readMapEnd()
              self.mapMap[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.I32:
          self.i32WithCustomDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefault()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyData()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.I32, -31)
      oprot.writeI32(self.i32WithCustomDefault)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter75,viter76 in self.mapMap.items():
        oprot.writeString(kiter75.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter75, bytes) else oprot.writeString(kiter75)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter76))
        for kiter77,viter78 in viter76.items():
          oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
          oprot.writeI32(viter78)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter79 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter79))
        for kiter80,viter81 in iter79.items():
          oprot.writeString(kiter80.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter80, bytes) else oprot.writeString(kiter80)
          oprot.writeI32(viter81)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter82,viter83 in self.optMapVal.items():
        oprot.writeString(kiter82.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter82, bytes) else oprot.writeString(kiter82)
        oprot.writeString(viter83.encode('utf-8')) if UTF8STRINGS and not isinstance(viter83, bytes) else oprot.writeString(viter83)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter84 in self.optSetVal:
        oprot.writeString(iter84.encode('utf-8')) if UTF8STRINGS and not isinstance(iter84, bytes) else oprot.writeString(iter84)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter85 in self.optListVal:
        oprot.writeI16(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      if wrap_enum_constants:
        self.enumVal = ThriftEnumWrapper(MyEnum, self.enumVal)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, **kwargs)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, **kwargs)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, **kwargs)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      if wrap_enum_constants:
        self.optEnumVal = ThriftEnumWrapper(MyEnum, self.optEnumVal)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, **kwargs)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, **kwargs)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e86 in json_obj['optListVal']:
        if _tmp_e86 > 0x7fff or _tmp_e86 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e86)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e87 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e87)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k88, _tmp_v89 in json_obj['optMapVal'].items():
        _tmp_kp90 = _tmp_k88
        self.optMapVal[_tmp_kp90] = _tmp_v89
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e91 in json_obj['listMap']:
        _map92 = dict_cls()
        for _tmp_k93, _tmp_v94 in _tmp_e91.items():
          _tmp_kp95 = _tmp_k93
          if _tmp_v94 > 0x7fffffff or _tmp_v94 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map92[_tmp_kp95] = _tmp_v94
        self.listMap.append(_map92)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k96, _tmp_v97 in json_obj['mapMap'].items():
        _tmp_kp98 = _tmp_k96
        _map99 = dict_cls()
        for _tmp_k100, _tmp_v101 in _tmp_v97.items():
          _tmp_kp102 = _tmp_k100
          if _tmp_v101 > 0x7fffffff or _tmp_v101 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map99[_tmp_kp102] = _tmp_v101
        self.mapMap[_tmp_kp98] = _map99
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = json_obj['i32WithCustomDefault']
      if self.i32WithCustomDefault > 0x7fffffff or self.i32WithCustomDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefault()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, **kwargs)
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyData()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, **kwargs)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStruct, self)

  def _to_py_deprecated(self):
    return self

class Recursive:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype104, _vtype105, _size103 ) = iprot.readMapBegin() 
          if _size103 >= 0:
            for _i107 in range(_size103):
              _key108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val109 = Recursive()
              _val109.read(iprot)
              self.nodes[_key108] = _val109
          else: 
            while iprot.peekMap():
              _key110 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val111 = Recursive()
              _val111.read(iprot)
              self.nodes[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Recursive')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter112,viter113 in self.nodes.items():
        oprot.writeString(kiter112.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter112, bytes) else oprot.writeString(kiter112)
        viter113.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k114, _tmp_v115 in json_obj['nodes'].items():
        _tmp_kp116 = _tmp_k114
        _struct117 = Recursive()
        _struct117.readFromJson(_tmp_v115, is_text=False, **kwargs)
        self.nodes[_tmp_kp116] = _struct117

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Recursive, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Recursive, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, **kwargs)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class Loop:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = Bar()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Loop')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = Bar()
      self.bar.readFromJson(json_obj['bar'], is_text=False, **kwargs)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Loop, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Loop, self)

  def _to_py_deprecated(self):
    return self

class RefFields:
  r"""
  Attributes:
   - unique
   - shared_const
   - shared_mustable
   - opt_unique
   - opt_shared_const
   - opt_shared_mustable
   - opt_box
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.unique = []
          (_etype121, _size118) = iprot.readListBegin()
          if _size118 >= 0:
            for _i122 in range(_size118):
              _elem123 = iprot.readI32()
              self.unique.append(_elem123)
          else: 
            while iprot.peekList():
              _elem124 = iprot.readI32()
              self.unique.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.shared_const = []
          (_etype128, _size125) = iprot.readListBegin()
          if _size125 >= 0:
            for _i129 in range(_size125):
              _elem130 = iprot.readI32()
              self.shared_const.append(_elem130)
          else: 
            while iprot.peekList():
              _elem131 = iprot.readI32()
              self.shared_const.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.shared_mustable = []
          (_etype135, _size132) = iprot.readListBegin()
          if _size132 >= 0:
            for _i136 in range(_size132):
              _elem137 = iprot.readI32()
              self.shared_mustable.append(_elem137)
          else: 
            while iprot.peekList():
              _elem138 = iprot.readI32()
              self.shared_mustable.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.opt_unique = []
          (_etype142, _size139) = iprot.readListBegin()
          if _size139 >= 0:
            for _i143 in range(_size139):
              _elem144 = iprot.readI32()
              self.opt_unique.append(_elem144)
          else: 
            while iprot.peekList():
              _elem145 = iprot.readI32()
              self.opt_unique.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.opt_shared_const = []
          (_etype149, _size146) = iprot.readListBegin()
          if _size146 >= 0:
            for _i150 in range(_size146):
              _elem151 = iprot.readI32()
              self.opt_shared_const.append(_elem151)
          else: 
            while iprot.peekList():
              _elem152 = iprot.readI32()
              self.opt_shared_const.append(_elem152)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.opt_shared_mustable = []
          (_etype156, _size153) = iprot.readListBegin()
          if _size153 >= 0:
            for _i157 in range(_size153):
              _elem158 = iprot.readI32()
              self.opt_shared_mustable.append(_elem158)
          else: 
            while iprot.peekList():
              _elem159 = iprot.readI32()
              self.opt_shared_mustable.append(_elem159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.opt_box = []
          (_etype163, _size160) = iprot.readListBegin()
          if _size160 >= 0:
            for _i164 in range(_size160):
              _elem165 = iprot.readI32()
              self.opt_box.append(_elem165)
          else: 
            while iprot.peekList():
              _elem166 = iprot.readI32()
              self.opt_box.append(_elem166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RefFields')
    if self.unique != None:
      oprot.writeFieldBegin('unique', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.unique))
      for iter167 in self.unique:
        oprot.writeI32(iter167)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shared_const != None:
      oprot.writeFieldBegin('shared_const', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.shared_const))
      for iter168 in self.shared_const:
        oprot.writeI32(iter168)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shared_mustable != None:
      oprot.writeFieldBegin('shared_mustable', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.shared_mustable))
      for iter169 in self.shared_mustable:
        oprot.writeI32(iter169)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.opt_unique != None:
      oprot.writeFieldBegin('opt_unique', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.opt_unique))
      for iter170 in self.opt_unique:
        oprot.writeI32(iter170)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.opt_shared_const != None:
      oprot.writeFieldBegin('opt_shared_const', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.opt_shared_const))
      for iter171 in self.opt_shared_const:
        oprot.writeI32(iter171)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.opt_shared_mustable != None:
      oprot.writeFieldBegin('opt_shared_mustable', TType.LIST, 6)
      oprot.writeListBegin(TType.I32, len(self.opt_shared_mustable))
      for iter172 in self.opt_shared_mustable:
        oprot.writeI32(iter172)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.opt_box != None:
      oprot.writeFieldBegin('opt_box', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.opt_box))
      for iter173 in self.opt_box:
        oprot.writeI32(iter173)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'unique' in json_obj and json_obj['unique'] is not None:
      self.unique = []
      for _tmp_e174 in json_obj['unique']:
        if _tmp_e174 > 0x7fffffff or _tmp_e174 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.unique.append(_tmp_e174)
    if 'shared_const' in json_obj and json_obj['shared_const'] is not None:
      self.shared_const = []
      for _tmp_e175 in json_obj['shared_const']:
        if _tmp_e175 > 0x7fffffff or _tmp_e175 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.shared_const.append(_tmp_e175)
    if 'shared_mustable' in json_obj and json_obj['shared_mustable'] is not None:
      self.shared_mustable = []
      for _tmp_e176 in json_obj['shared_mustable']:
        if _tmp_e176 > 0x7fffffff or _tmp_e176 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.shared_mustable.append(_tmp_e176)
    if 'opt_unique' in json_obj and json_obj['opt_unique'] is not None:
      self.opt_unique = []
      for _tmp_e177 in json_obj['opt_unique']:
        if _tmp_e177 > 0x7fffffff or _tmp_e177 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.opt_unique.append(_tmp_e177)
    if 'opt_shared_const' in json_obj and json_obj['opt_shared_const'] is not None:
      self.opt_shared_const = []
      for _tmp_e178 in json_obj['opt_shared_const']:
        if _tmp_e178 > 0x7fffffff or _tmp_e178 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.opt_shared_const.append(_tmp_e178)
    if 'opt_shared_mustable' in json_obj and json_obj['opt_shared_mustable'] is not None:
      self.opt_shared_mustable = []
      for _tmp_e179 in json_obj['opt_shared_mustable']:
        if _tmp_e179 > 0x7fffffff or _tmp_e179 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.opt_shared_mustable.append(_tmp_e179)
    if 'opt_box' in json_obj and json_obj['opt_box'] is not None:
      self.opt_box = []
      for _tmp_e180 in json_obj['opt_box']:
        if _tmp_e180 > 0x7fffffff or _tmp_e180 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.opt_box.append(_tmp_e180)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.unique is not None:
      value = pprint.pformat(self.unique, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unique=%s' % (value))
    if self.shared_const is not None:
      value = pprint.pformat(self.shared_const, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    shared_const=%s' % (value))
    if self.shared_mustable is not None:
      value = pprint.pformat(self.shared_mustable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    shared_mustable=%s' % (value))
    if self.opt_unique is not None:
      value = pprint.pformat(self.opt_unique, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_unique=%s' % (value))
    if self.opt_shared_const is not None:
      value = pprint.pformat(self.opt_shared_const, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_shared_const=%s' % (value))
    if self.opt_shared_mustable is not None:
      value = pprint.pformat(self.opt_shared_mustable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_shared_mustable=%s' % (value))
    if self.opt_box is not None:
      value = pprint.pformat(self.opt_box, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_box=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'unique',
      'shared_const',
      'shared_mustable',
      'opt_unique',
      'opt_shared_const',
      'opt_shared_mustable',
      'opt_box',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RefFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RefFields, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(MyData)
MyData.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'data1', True, None, 3, ), # 1
  (2, TType.I32, 'data2', None, None, 3, ), # 2
)))

MyData.thrift_struct_annotations = {
}
MyData.thrift_field_annotations = {
}

def MyData__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyData.__init__ = MyData__init__

def MyData__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyData.__getstate__ = lambda self: self.__dict__.copy()
MyData.__setstate__ = MyData__setstate__

all_structs.append(MyDataWithCustomDefault)
MyDataWithCustomDefault.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'data1', True, "1", 3, ), # 1
  (2, TType.I32, 'data2', None, 2, 3, ), # 2
)))

MyDataWithCustomDefault.thrift_struct_annotations = {
}
MyDataWithCustomDefault.thrift_field_annotations = {
}

def MyDataWithCustomDefault__init__(self, data1=MyDataWithCustomDefault.thrift_spec[1][4], data2=MyDataWithCustomDefault.thrift_spec[2][4],):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefault.__init__ = MyDataWithCustomDefault__init__

def MyDataWithCustomDefault__setstate__(self, state):
  state.setdefault('data1', "1")
  state.setdefault('data2', 2)
  self.__dict__ = state

MyDataWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefault.__setstate__ = MyDataWithCustomDefault__setstate__

all_structs.append(InnerUnion)
InnerUnion.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'innerOption', False, None, 2, ), # 1
)))

InnerUnion.thrift_struct_annotations = {
}
InnerUnion.thrift_field_annotations = {
}

def InnerUnion__init__(self, innerOption=None,):
  self.field = 0
  self.value = None
  if innerOption is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = innerOption

InnerUnion.__init__ = InnerUnion__init__

all_structs.append(MyUnion)
MyUnion.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'option1', True, None, 2, ), # 1
  (2, TType.I32, 'option2', None, None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 3
)))

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, option1=None, option2=None, option3=None,):
  self.field = 0
  self.value = None
  if option1 is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = option1
  if option2 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = option2
  if option3 is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = option3

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStruct)
MyStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 3, ), # -32
  (-31, TType.I32, 'i32WithCustomDefault', None, 1, 3, ), # -31
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 3, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 3, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 3, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 3, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 3, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 3, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 3, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 3, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 3, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 3, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 3, ), # -1
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyData, MyData.thrift_spec, False], MyData(**{
    "data1" : "1",
    "data2" : 2,
  }), 3, ), # 1
)))

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, enumVal=None, structVal=None, unionVal=None, lateStructVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optEnumVal=None, optStructVal=None, optLateStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, listMap=None, mapMap=None, i32WithCustomDefault=MyStruct.thrift_spec[1][4], structWithCustomDefault=None, structWithFieldCustomDefault=MyStruct.thrift_spec[33][4],):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.enumVal = enumVal
  self.structVal = structVal
  self.unionVal = unionVal
  self.lateStructVal = lateStructVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optEnumVal = optEnumVal
  self.optStructVal = optStructVal
  self.optLateStructVal = optLateStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.listMap = listMap
  self.mapMap = mapMap
  self.i32WithCustomDefault = i32WithCustomDefault
  self.structWithCustomDefault = structWithCustomDefault
  if structWithFieldCustomDefault is self.thrift_spec[33][4]:
    structWithFieldCustomDefault = MyData(**{
    "data1" : "1",
    "data2" : 2,
  })
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('structVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('listMap', None)
  state.setdefault('mapMap', None)
  state.setdefault('i32WithCustomDefault', 1)
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('structWithFieldCustomDefault', MyData(**{
    "data1" : "1",
    "data2" : 2,
  }))
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(LateDefStruct)
LateDefStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

LateDefStruct.thrift_struct_annotations = {
}
LateDefStruct.thrift_field_annotations = {
}

all_structs.append(Recursive)
Recursive.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 3, ), # -1
)))

Recursive.thrift_struct_annotations = {
}
Recursive.thrift_field_annotations = {
}

def Recursive__init__(self, nodes=None,):
  self.nodes = nodes

Recursive.__init__ = Recursive__init__

def Recursive__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

Recursive.__getstate__ = lambda self: self.__dict__.copy()
Recursive.__setstate__ = Recursive__setstate__

all_structs.append(Bar)
Bar.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 3, ), # -1
)))

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, loop=None,):
  self.loop = loop

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(Loop)
Loop.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (-1, TType.STRUCT, 'bar', [Bar, Bar.thrift_spec, False], None, 3, ), # -1
)))

Loop.thrift_struct_annotations = {
}
Loop.thrift_field_annotations = {
}

def Loop__init__(self, bar=None,):
  self.bar = bar

Loop.__init__ = Loop__init__

def Loop__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

Loop.__getstate__ = lambda self: self.__dict__.copy()
Loop.__setstate__ = Loop__setstate__

all_structs.append(RefFields)
RefFields.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'unique', (TType.I32,None), None, 3, ), # 1
  (2, TType.LIST, 'shared_const', (TType.I32,None), None, 3, ), # 2
  (3, TType.LIST, 'shared_mustable', (TType.I32,None), None, 3, ), # 3
  (4, TType.LIST, 'opt_unique', (TType.I32,None), None, 1, ), # 4
  (5, TType.LIST, 'opt_shared_const', (TType.I32,None), None, 1, ), # 5
  (6, TType.LIST, 'opt_shared_mustable', (TType.I32,None), None, 1, ), # 6
  (7, TType.LIST, 'opt_box', (TType.I32,None), None, 1, ), # 7
)))

RefFields.thrift_struct_annotations = {
}
RefFields.thrift_field_annotations = {
}

def RefFields__init__(self, unique=None, shared_const=None, shared_mustable=None, opt_unique=None, opt_shared_const=None, opt_shared_mustable=None, opt_box=None,):
  self.unique = unique
  self.shared_const = shared_const
  self.shared_mustable = shared_mustable
  self.opt_unique = opt_unique
  self.opt_shared_const = opt_shared_const
  self.opt_shared_mustable = opt_shared_mustable
  self.opt_box = opt_box

RefFields.__init__ = RefFields__init__

def RefFields__setstate__(self, state):
  state.setdefault('unique', None)
  state.setdefault('shared_const', None)
  state.setdefault('shared_mustable', None)
  state.setdefault('opt_unique', None)
  state.setdefault('opt_shared_const', None)
  state.setdefault('opt_shared_mustable', None)
  state.setdefault('opt_box', None)
  self.__dict__ = state

RefFields.__getstate__ = lambda self: self.__dict__.copy()
RefFields.__setstate__ = RefFields__setstate__

fix_spec(all_structs)
del all_structs
