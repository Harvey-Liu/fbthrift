<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace test\fixtures\patch;

/**
 * Original thrift enum:-
 * MyEnum
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/MyEnum'))>>
enum MyEnum: int {
  MyValue0 = 0;
}

class MyEnum_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return \tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "module.MyEnum",
        "elements" => dict[
          0 => "MyValue0",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Original thrift struct:-
 * MyData
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/MyData'))>>
class MyData implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'data1',
      'is_terse' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'data2',
      'is_terse' => true,
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'data1' => 1,
    'data2' => 2,
  ];

  const type TConstructorShape = shape(
    ?'data1' => ?string,
    ?'data2' => ?int,
  );

  const type TShape = shape(
    'data1' => string,
    'data2' => int,
    ...
  );
  const int STRUCTURAL_ID = 5497211930825790974;
  /**
   * Original thrift field:-
   * 1: string data1
   */
  public string $data1;
  /**
   * Original thrift field:-
   * 2: i32 data2
   */
  public int $data2;

  public function __construct(?string $data1 = null, ?int $data2 = null)[] {
    $this->data1 = $data1 ?? '';
    $this->data2 = $data2 ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'data1'),
      Shapes::idx($shape, 'data2'),
    );
  }

  public function getName()[]: string {
    return 'MyData';
  }

  public function clearTerseFields()[write_props]: void {
    $this->data1 = '';
    $this->data2 = 0;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyData",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "data1",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "data2",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['data1'],
      $shape['data2'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'data1' => $this->data1,
      'data2' => $this->data2,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'data1') !== null) {
      $this->data1 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['data1']);
    }
    if (idx($parsed, 'data2') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['data2']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->data2 = (int)$_tmp0;
      }
    }
  }

}

/**
 * Original thrift struct:-
 * MyDataWithCustomDefault
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/MyDataWithCustomDefault'))>>
class MyDataWithCustomDefault implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'data1',
      'is_terse' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'data2',
      'is_terse' => true,
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'data1' => 1,
    'data2' => 2,
  ];

  const type TConstructorShape = shape(
    ?'data1' => ?string,
    ?'data2' => ?int,
  );

  const type TShape = shape(
    'data1' => string,
    'data2' => int,
    ...
  );
  const int STRUCTURAL_ID = 5497211930825790974;
  /**
   * Original thrift field:-
   * 1: string data1
   */
  public string $data1;
  /**
   * Original thrift field:-
   * 2: i32 data2
   */
  public int $data2;

  public function __construct(?string $data1 = null, ?int $data2 = null)[] {
    $this->data1 = $data1 ?? "1";
    $this->data2 = $data2 ?? 2;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'data1'),
      Shapes::idx($shape, 'data2'),
    );
  }

  public function getName()[]: string {
    return 'MyDataWithCustomDefault';
  }

  public function clearTerseFields()[write_props]: void {
    $this->data1 = '';
    $this->data2 = 0;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyDataWithCustomDefault",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "data1",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "data2",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['data1'],
      $shape['data2'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'data1' => $this->data1,
      'data2' => $this->data2,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'data1') !== null) {
      $this->data1 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['data1']);
    }
    if (idx($parsed, 'data2') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['data2']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->data2 = (int)$_tmp0;
      }
    }
  }

}

enum InnerUnionEnum: int {
  _EMPTY_ = 0;
  innerOption = 1;
}

/**
 * Original thrift union:-
 * InnerUnion
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/InnerUnion'))>>
class InnerUnion implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftUnion<\test\fixtures\patch\InnerUnionEnum>, \IThriftShapishSyncStruct {
  use \ThriftUnionSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'innerOption',
      'union' => true,
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'innerOption' => 1,
  ];

  const type TConstructorShape = shape(
    ?'innerOption' => ?string,
  );

  const type TShape = shape(
    ?'innerOption' => ?string,
    ...
  );
  const int STRUCTURAL_ID = 8244649827300221001;
  /**
   * Original thrift field:-
   * 1: binary innerOption
   */
  public ?string $innerOption;
  protected \test\fixtures\patch\InnerUnionEnum $_type = \test\fixtures\patch\InnerUnionEnum::_EMPTY_;

  public function __construct(?string $innerOption = null)[] {
    $this->_type = \test\fixtures\patch\InnerUnionEnum::_EMPTY_;
    if ($innerOption !== null) {
      $this->innerOption = $innerOption;
      $this->_type = \test\fixtures\patch\InnerUnionEnum::innerOption;
    }
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'innerOption'),
    );
  }

  public function getName()[]: string {
    return 'InnerUnion';
  }

  public function getType()[]: \test\fixtures\patch\InnerUnionEnum {
    return $this->_type;
  }

  public function reset()[write_props]: void {
    switch ($this->_type) {
      case \test\fixtures\patch\InnerUnionEnum::innerOption:
        $this->innerOption = null;
        break;
      case \test\fixtures\patch\InnerUnionEnum::_EMPTY_:
        break;
    }
    $this->_type = \test\fixtures\patch\InnerUnionEnum::_EMPTY_;
  }

  public function set_innerOption(string $innerOption)[write_props]: this {
    $this->reset();
    $this->_type = \test\fixtures\patch\InnerUnionEnum::innerOption;
    $this->innerOption = $innerOption;
    return $this;
  }

  public function get_innerOption()[]: ?string {
    return $this->innerOption;
  }

  public function getx_innerOption()[]: string {
    invariant(
      $this->_type === \test\fixtures\patch\InnerUnionEnum::innerOption,
      'get_innerOption called on an instance of InnerUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->innerOption as nonnull;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.InnerUnion",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "innerOption",
            )
          ),
        ],
        "is_union" => true,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'innerOption'),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'innerOption' => $this->innerOption,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $this->_type = \test\fixtures\patch\InnerUnionEnum::_EMPTY_;
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'innerOption') !== null) {
      $this->innerOption = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['innerOption']);
      $this->_type = \test\fixtures\patch\InnerUnionEnum::innerOption;
    }
  }

}

enum MyUnionEnum: int {
  _EMPTY_ = 0;
  option1 = 1;
  option2 = 2;
  option3 = 3;
}

/**
 * Original thrift union:-
 * MyUnion
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/MyUnion'))>>
class MyUnion implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftUnion<\test\fixtures\patch\MyUnionEnum>, \IThriftShapishSyncStruct {
  use \ThriftUnionSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'option1',
      'union' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'option2',
      'union' => true,
      'type' => \TType::I32,
    ),
    3 => shape(
      'var' => 'option3',
      'union' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\InnerUnion::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'option1' => 1,
    'option2' => 2,
    'option3' => 3,
  ];

  const type TConstructorShape = shape(
    ?'option1' => ?string,
    ?'option2' => ?int,
    ?'option3' => ?\test\fixtures\patch\InnerUnion,
  );

  const type TShape = shape(
    ?'option1' => ?string,
    ?'option2' => ?int,
    ?'option3' => ?\test\fixtures\patch\InnerUnion::TShape,
    ...
  );
  const int STRUCTURAL_ID = 2373941666242479705;
  /**
   * Original thrift field:-
   * 1: string option1
   */
  public ?string $option1;
  /**
   * Original thrift field:-
   * 2: i32 option2
   */
  public ?int $option2;
  /**
   * Original thrift field:-
   * 3: module.InnerUnion option3
   */
  public ?\test\fixtures\patch\InnerUnion $option3;
  protected \test\fixtures\patch\MyUnionEnum $_type = \test\fixtures\patch\MyUnionEnum::_EMPTY_;

  public function __construct(?string $option1 = null, ?int $option2 = null, ?\test\fixtures\patch\InnerUnion $option3 = null)[] {
    $this->_type = \test\fixtures\patch\MyUnionEnum::_EMPTY_;
    if ($option1 !== null) {
      $this->option1 = $option1;
      $this->_type = \test\fixtures\patch\MyUnionEnum::option1;
    }
    if ($option2 !== null) {
      $this->option2 = $option2;
      $this->_type = \test\fixtures\patch\MyUnionEnum::option2;
    }
    if ($option3 !== null) {
      $this->option3 = $option3;
      $this->_type = \test\fixtures\patch\MyUnionEnum::option3;
    }
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'option1'),
      Shapes::idx($shape, 'option2'),
      Shapes::idx($shape, 'option3'),
    );
  }

  public function getName()[]: string {
    return 'MyUnion';
  }

  public function getType()[]: \test\fixtures\patch\MyUnionEnum {
    return $this->_type;
  }

  public function reset()[write_props]: void {
    switch ($this->_type) {
      case \test\fixtures\patch\MyUnionEnum::option1:
        $this->option1 = null;
        break;
      case \test\fixtures\patch\MyUnionEnum::option2:
        $this->option2 = null;
        break;
      case \test\fixtures\patch\MyUnionEnum::option3:
        $this->option3 = null;
        break;
      case \test\fixtures\patch\MyUnionEnum::_EMPTY_:
        break;
    }
    $this->_type = \test\fixtures\patch\MyUnionEnum::_EMPTY_;
  }

  public function set_option1(string $option1)[write_props]: this {
    $this->reset();
    $this->_type = \test\fixtures\patch\MyUnionEnum::option1;
    $this->option1 = $option1;
    return $this;
  }

  public function get_option1()[]: ?string {
    return $this->option1;
  }

  public function getx_option1()[]: string {
    invariant(
      $this->_type === \test\fixtures\patch\MyUnionEnum::option1,
      'get_option1 called on an instance of MyUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->option1 as nonnull;
  }

  public function set_option2(int $option2)[write_props]: this {
    $this->reset();
    $this->_type = \test\fixtures\patch\MyUnionEnum::option2;
    $this->option2 = $option2;
    return $this;
  }

  public function get_option2()[]: ?int {
    return $this->option2;
  }

  public function getx_option2()[]: int {
    invariant(
      $this->_type === \test\fixtures\patch\MyUnionEnum::option2,
      'get_option2 called on an instance of MyUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->option2 as nonnull;
  }

  public function set_option3(\test\fixtures\patch\InnerUnion $option3)[write_props]: this {
    $this->reset();
    $this->_type = \test\fixtures\patch\MyUnionEnum::option3;
    $this->option3 = $option3;
    return $this;
  }

  public function get_option3()[]: ?\test\fixtures\patch\InnerUnion {
    return $this->option3;
  }

  public function getx_option3()[]: \test\fixtures\patch\InnerUnion {
    invariant(
      $this->_type === \test\fixtures\patch\MyUnionEnum::option3,
      'get_option3 called on an instance of MyUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->option3 as nonnull;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyUnion",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "option1",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "option2",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.InnerUnion",
                    )
                  ),
                )
              ),
              "name" => "option3",
            )
          ),
        ],
        "is_union" => true,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'option1'),
      Shapes::idx($shape, 'option2'),
      Shapes::idx($shape, 'option3') |> $$ === null ? null : (\test\fixtures\patch\InnerUnion::__fromShape($$)),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'option1' => $this->option1,
      'option2' => $this->option2,
      'option3' => $this->option3?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $this->_type = \test\fixtures\patch\MyUnionEnum::_EMPTY_;
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'option1') !== null) {
      $this->option1 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['option1']);
      $this->_type = \test\fixtures\patch\MyUnionEnum::option1;
    }
    if (idx($parsed, 'option2') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['option2']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->option2 = (int)$_tmp0;
      }
      $this->_type = \test\fixtures\patch\MyUnionEnum::option2;
    }
    if (idx($parsed, 'option3') !== null) {
      $_tmp1 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\InnerUnion>($parsed['option3']));
      $_tmp2 = \test\fixtures\patch\InnerUnion::withDefaultValues();
      $_tmp2->readFromJson($_tmp1);
      $this->option3 = $_tmp2;
      $this->_type = \test\fixtures\patch\MyUnionEnum::option3;
    }
  }

}

/**
 * Original thrift struct:-
 * MyStruct
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/MyStruct'))>>
class MyStruct implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    -1 => shape(
      'var' => 'boolVal',
      'is_terse' => true,
      'type' => \TType::BOOL,
    ),
    -2 => shape(
      'var' => 'byteVal',
      'is_terse' => true,
      'type' => \TType::BYTE,
    ),
    -3 => shape(
      'var' => 'i16Val',
      'is_terse' => true,
      'type' => \TType::I16,
    ),
    -4 => shape(
      'var' => 'i32Val',
      'is_terse' => true,
      'type' => \TType::I32,
    ),
    -5 => shape(
      'var' => 'i64Val',
      'is_terse' => true,
      'type' => \TType::I64,
    ),
    -6 => shape(
      'var' => 'floatVal',
      'is_terse' => true,
      'type' => \TType::FLOAT,
    ),
    -7 => shape(
      'var' => 'doubleVal',
      'is_terse' => true,
      'type' => \TType::DOUBLE,
    ),
    -8 => shape(
      'var' => 'stringVal',
      'is_terse' => true,
      'type' => \TType::STRING,
    ),
    -9 => shape(
      'var' => 'binaryVal',
      'is_terse' => true,
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    -10 => shape(
      'var' => 'enumVal',
      'is_terse' => true,
      'type' => \TType::I32,
      'enum' => \test\fixtures\patch\MyEnum::class,
    ),
    -11 => shape(
      'var' => 'structVal',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\MyData::class,
    ),
    -12 => shape(
      'var' => 'unionVal',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\MyUnion::class,
    ),
    -13 => shape(
      'var' => 'lateStructVal',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\LateDefStruct::class,
    ),
    -14 => shape(
      'var' => 'optBoolVal',
      'type' => \TType::BOOL,
    ),
    -15 => shape(
      'var' => 'optByteVal',
      'type' => \TType::BYTE,
    ),
    -16 => shape(
      'var' => 'optI16Val',
      'type' => \TType::I16,
    ),
    -17 => shape(
      'var' => 'optI32Val',
      'type' => \TType::I32,
    ),
    -18 => shape(
      'var' => 'optI64Val',
      'type' => \TType::I64,
    ),
    -19 => shape(
      'var' => 'optFloatVal',
      'type' => \TType::FLOAT,
    ),
    -20 => shape(
      'var' => 'optDoubleVal',
      'type' => \TType::DOUBLE,
    ),
    -21 => shape(
      'var' => 'optStringVal',
      'type' => \TType::STRING,
    ),
    -22 => shape(
      'var' => 'optBinaryVal',
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    -23 => shape(
      'var' => 'optEnumVal',
      'type' => \TType::I32,
      'enum' => \test\fixtures\patch\MyEnum::class,
    ),
    -24 => shape(
      'var' => 'optStructVal',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\MyData::class,
    ),
    -25 => shape(
      'var' => 'optLateStructVal',
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\LateDefStruct::class,
    ),
    -26 => shape(
      'var' => 'optListVal',
      'type' => \TType::LST,
      'etype' => \TType::I16,
      'elem' => shape(
        'type' => \TType::I16,
      ),
      'format' => 'collection',
    ),
    -27 => shape(
      'var' => 'optSetVal',
      'type' => \TType::SET,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    -28 => shape(
      'var' => 'optMapVal',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    -29 => shape(
      'var' => 'listMap',
      'is_terse' => true,
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::I32,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    -30 => shape(
      'var' => 'mapMap',
      'is_terse' => true,
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::MAP,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::STRING,
        'vtype' => \TType::I32,
        'key' => shape(
          'type' => \TType::STRING,
        ),
        'val' => shape(
          'type' => \TType::I32,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    -31 => shape(
      'var' => 'i32WithCustomDefault',
      'is_terse' => true,
      'type' => \TType::I32,
    ),
    -32 => shape(
      'var' => 'structWithCustomDefault',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\MyDataWithCustomDefault::class,
    ),
    1 => shape(
      'var' => 'structWithFieldCustomDefault',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\MyData::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'boolVal' => -1,
    'byteVal' => -2,
    'i16Val' => -3,
    'i32Val' => -4,
    'i64Val' => -5,
    'floatVal' => -6,
    'doubleVal' => -7,
    'stringVal' => -8,
    'binaryVal' => -9,
    'enumVal' => -10,
    'structVal' => -11,
    'unionVal' => -12,
    'lateStructVal' => -13,
    'optBoolVal' => -14,
    'optByteVal' => -15,
    'optI16Val' => -16,
    'optI32Val' => -17,
    'optI64Val' => -18,
    'optFloatVal' => -19,
    'optDoubleVal' => -20,
    'optStringVal' => -21,
    'optBinaryVal' => -22,
    'optEnumVal' => -23,
    'optStructVal' => -24,
    'optLateStructVal' => -25,
    'optListVal' => -26,
    'optSetVal' => -27,
    'optMapVal' => -28,
    'listMap' => -29,
    'mapMap' => -30,
    'i32WithCustomDefault' => -31,
    'structWithCustomDefault' => -32,
    'structWithFieldCustomDefault' => 1,
  ];

  const type TConstructorShape = shape(
    ?'boolVal' => ?bool,
    ?'byteVal' => ?int,
    ?'i16Val' => ?int,
    ?'i32Val' => ?int,
    ?'i64Val' => ?int,
    ?'floatVal' => ?float,
    ?'doubleVal' => ?float,
    ?'stringVal' => ?string,
    ?'binaryVal' => ?string,
    ?'enumVal' => ?\test\fixtures\patch\MyEnum,
    ?'structVal' => ?\test\fixtures\patch\MyData,
    ?'unionVal' => ?\test\fixtures\patch\MyUnion,
    ?'lateStructVal' => ?\test\fixtures\patch\LateDefStruct,
    ?'optBoolVal' => ?bool,
    ?'optByteVal' => ?int,
    ?'optI16Val' => ?int,
    ?'optI32Val' => ?int,
    ?'optI64Val' => ?int,
    ?'optFloatVal' => ?float,
    ?'optDoubleVal' => ?float,
    ?'optStringVal' => ?string,
    ?'optBinaryVal' => ?string,
    ?'optEnumVal' => ?\test\fixtures\patch\MyEnum,
    ?'optStructVal' => ?\test\fixtures\patch\MyData,
    ?'optLateStructVal' => ?\test\fixtures\patch\LateDefStruct,
    ?'optListVal' => ?Vector<int>,
    ?'optSetVal' => ?Set<string>,
    ?'optMapVal' => ?Map<string, string>,
    ?'listMap' => ?Vector<Map<string, int>>,
    ?'mapMap' => ?Map<string, Map<string, int>>,
    ?'i32WithCustomDefault' => ?int,
    ?'structWithCustomDefault' => ?\test\fixtures\patch\MyDataWithCustomDefault,
    ?'structWithFieldCustomDefault' => ?\test\fixtures\patch\MyData,
  );

  const type TShape = shape(
    'boolVal' => bool,
    'byteVal' => int,
    'i16Val' => int,
    'i32Val' => int,
    'i64Val' => int,
    'floatVal' => float,
    'doubleVal' => float,
    'stringVal' => string,
    'binaryVal' => string,
    ?'enumVal' => ?\test\fixtures\patch\MyEnum,
    ?'structVal' => ?\test\fixtures\patch\MyData::TShape,
    ?'unionVal' => ?\test\fixtures\patch\MyUnion::TShape,
    ?'lateStructVal' => ?\test\fixtures\patch\LateDefStruct::TShape,
    ?'optBoolVal' => ?bool,
    ?'optByteVal' => ?int,
    ?'optI16Val' => ?int,
    ?'optI32Val' => ?int,
    ?'optI64Val' => ?int,
    ?'optFloatVal' => ?float,
    ?'optDoubleVal' => ?float,
    ?'optStringVal' => ?string,
    ?'optBinaryVal' => ?string,
    ?'optEnumVal' => ?\test\fixtures\patch\MyEnum,
    ?'optStructVal' => ?\test\fixtures\patch\MyData::TShape,
    ?'optLateStructVal' => ?\test\fixtures\patch\LateDefStruct::TShape,
    ?'optListVal' => ?vec<int>,
    ?'optSetVal' => ?dict<string, bool>,
    ?'optMapVal' => ?dict<string, string>,
    'listMap' => vec<dict<string, int>>,
    'mapMap' => dict<string, dict<string, int>>,
    'i32WithCustomDefault' => int,
    ?'structWithCustomDefault' => ?\test\fixtures\patch\MyDataWithCustomDefault::TShape,
    ?'structWithFieldCustomDefault' => ?\test\fixtures\patch\MyData::TShape,
    ...
  );
  const int STRUCTURAL_ID = 8604220942000869633;
  /**
   * Original thrift field:-
   * -1: bool boolVal
   */
  public bool $boolVal;
  /**
   * Original thrift field:-
   * -2: byte byteVal
   */
  public int $byteVal;
  /**
   * Original thrift field:-
   * -3: i16 i16Val
   */
  public int $i16Val;
  /**
   * Original thrift field:-
   * -4: i32 i32Val
   */
  public int $i32Val;
  /**
   * Original thrift field:-
   * -5: i64 i64Val
   */
  public int $i64Val;
  /**
   * Original thrift field:-
   * -6: float floatVal
   */
  public float $floatVal;
  /**
   * Original thrift field:-
   * -7: double doubleVal
   */
  public float $doubleVal;
  /**
   * Original thrift field:-
   * -8: string stringVal
   */
  public string $stringVal;
  /**
   * Original thrift field:-
   * -9: binary binaryVal
   */
  public string $binaryVal;
  /**
   * Original thrift field:-
   * -10: module.MyEnum enumVal
   */
  public ?\test\fixtures\patch\MyEnum $enumVal;
  /**
   * Original thrift field:-
   * -11: module.MyData structVal
   */
  public ?\test\fixtures\patch\MyData $structVal;
  /**
   * Original thrift field:-
   * -12: module.MyUnion unionVal
   */
  public ?\test\fixtures\patch\MyUnion $unionVal;
  /**
   * Original thrift field:-
   * -13: module.LateDefStruct lateStructVal
   */
  public ?\test\fixtures\patch\LateDefStruct $lateStructVal;
  /**
   * Original thrift field:-
   * -14: bool optBoolVal
   */
  public ?bool $optBoolVal;
  /**
   * Original thrift field:-
   * -15: byte optByteVal
   */
  public ?int $optByteVal;
  /**
   * Original thrift field:-
   * -16: i16 optI16Val
   */
  public ?int $optI16Val;
  /**
   * Original thrift field:-
   * -17: i32 optI32Val
   */
  public ?int $optI32Val;
  /**
   * Original thrift field:-
   * -18: i64 optI64Val
   */
  public ?int $optI64Val;
  /**
   * Original thrift field:-
   * -19: float optFloatVal
   */
  public ?float $optFloatVal;
  /**
   * Original thrift field:-
   * -20: double optDoubleVal
   */
  public ?float $optDoubleVal;
  /**
   * Original thrift field:-
   * -21: string optStringVal
   */
  public ?string $optStringVal;
  /**
   * Original thrift field:-
   * -22: binary optBinaryVal
   */
  public ?string $optBinaryVal;
  /**
   * Original thrift field:-
   * -23: module.MyEnum optEnumVal
   */
  public ?\test\fixtures\patch\MyEnum $optEnumVal;
  /**
   * Original thrift field:-
   * -24: module.MyData optStructVal
   */
  public ?\test\fixtures\patch\MyData $optStructVal;
  /**
   * Original thrift field:-
   * -25: module.LateDefStruct optLateStructVal
   */
  public ?\test\fixtures\patch\LateDefStruct $optLateStructVal;
  /**
   * Original thrift field:-
   * -26: list<i16> optListVal
   */
  public ?Vector<int> $optListVal;
  /**
   * Original thrift field:-
   * -27: set<string> optSetVal
   */
  public ?Set<string> $optSetVal;
  /**
   * Original thrift field:-
   * -28: map<string, string> optMapVal
   */
  public ?Map<string, string> $optMapVal;
  /**
   * Original thrift field:-
   * -29: list<map<string, i32>> listMap
   */
  public Vector<Map<string, int>> $listMap;
  /**
   * Original thrift field:-
   * -30: map<string, map<string, i32>> mapMap
   */
  public Map<string, Map<string, int>> $mapMap;
  /**
   * Original thrift field:-
   * -31: i32 i32WithCustomDefault
   */
  public int $i32WithCustomDefault;
  /**
   * Original thrift field:-
   * -32: module.MyDataWithCustomDefault structWithCustomDefault
   */
  public ?\test\fixtures\patch\MyDataWithCustomDefault $structWithCustomDefault;
  /**
   * Original thrift field:-
   * 1: module.MyData structWithFieldCustomDefault
   */
  public ?\test\fixtures\patch\MyData $structWithFieldCustomDefault;

  public function __construct(?bool $boolVal = null, ?int $byteVal = null, ?int $i16Val = null, ?int $i32Val = null, ?int $i64Val = null, ?float $floatVal = null, ?float $doubleVal = null, ?string $stringVal = null, ?string $binaryVal = null, ?\test\fixtures\patch\MyEnum $enumVal = null, ?\test\fixtures\patch\MyData $structVal = null, ?\test\fixtures\patch\MyUnion $unionVal = null, ?\test\fixtures\patch\LateDefStruct $lateStructVal = null, ?bool $optBoolVal = null, ?int $optByteVal = null, ?int $optI16Val = null, ?int $optI32Val = null, ?int $optI64Val = null, ?float $optFloatVal = null, ?float $optDoubleVal = null, ?string $optStringVal = null, ?string $optBinaryVal = null, ?\test\fixtures\patch\MyEnum $optEnumVal = null, ?\test\fixtures\patch\MyData $optStructVal = null, ?\test\fixtures\patch\LateDefStruct $optLateStructVal = null, ?Vector<int> $optListVal = null, ?Set<string> $optSetVal = null, ?Map<string, string> $optMapVal = null, ?Vector<Map<string, int>> $listMap = null, ?Map<string, Map<string, int>> $mapMap = null, ?int $i32WithCustomDefault = null, ?\test\fixtures\patch\MyDataWithCustomDefault $structWithCustomDefault = null, ?\test\fixtures\patch\MyData $structWithFieldCustomDefault = null)[] {
    $this->boolVal = $boolVal ?? false;
    $this->byteVal = $byteVal ?? 0;
    $this->i16Val = $i16Val ?? 0;
    $this->i32Val = $i32Val ?? 0;
    $this->i64Val = $i64Val ?? 0;
    $this->floatVal = $floatVal ?? 0.0;
    $this->doubleVal = $doubleVal ?? 0.0;
    $this->stringVal = $stringVal ?? '';
    $this->binaryVal = $binaryVal ?? '';
    $this->enumVal = $enumVal;
    $this->structVal = $structVal;
    $this->unionVal = $unionVal;
    $this->lateStructVal = $lateStructVal;
    $this->optBoolVal = $optBoolVal;
    $this->optByteVal = $optByteVal;
    $this->optI16Val = $optI16Val;
    $this->optI32Val = $optI32Val;
    $this->optI64Val = $optI64Val;
    $this->optFloatVal = $optFloatVal;
    $this->optDoubleVal = $optDoubleVal;
    $this->optStringVal = $optStringVal;
    $this->optBinaryVal = $optBinaryVal;
    $this->optEnumVal = $optEnumVal;
    $this->optStructVal = $optStructVal;
    $this->optLateStructVal = $optLateStructVal;
    $this->optListVal = $optListVal;
    $this->optSetVal = $optSetVal;
    $this->optMapVal = $optMapVal;
    $this->listMap = $listMap ?? Vector {};
    $this->mapMap = $mapMap ?? Map {};
    $this->i32WithCustomDefault = $i32WithCustomDefault ?? 1;
    $this->structWithCustomDefault = $structWithCustomDefault;
    $this->structWithFieldCustomDefault = $structWithFieldCustomDefault;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'boolVal'),
      Shapes::idx($shape, 'byteVal'),
      Shapes::idx($shape, 'i16Val'),
      Shapes::idx($shape, 'i32Val'),
      Shapes::idx($shape, 'i64Val'),
      Shapes::idx($shape, 'floatVal'),
      Shapes::idx($shape, 'doubleVal'),
      Shapes::idx($shape, 'stringVal'),
      Shapes::idx($shape, 'binaryVal'),
      Shapes::idx($shape, 'enumVal'),
      Shapes::idx($shape, 'structVal'),
      Shapes::idx($shape, 'unionVal'),
      Shapes::idx($shape, 'lateStructVal'),
      Shapes::idx($shape, 'optBoolVal'),
      Shapes::idx($shape, 'optByteVal'),
      Shapes::idx($shape, 'optI16Val'),
      Shapes::idx($shape, 'optI32Val'),
      Shapes::idx($shape, 'optI64Val'),
      Shapes::idx($shape, 'optFloatVal'),
      Shapes::idx($shape, 'optDoubleVal'),
      Shapes::idx($shape, 'optStringVal'),
      Shapes::idx($shape, 'optBinaryVal'),
      Shapes::idx($shape, 'optEnumVal'),
      Shapes::idx($shape, 'optStructVal'),
      Shapes::idx($shape, 'optLateStructVal'),
      Shapes::idx($shape, 'optListVal'),
      Shapes::idx($shape, 'optSetVal'),
      Shapes::idx($shape, 'optMapVal'),
      Shapes::idx($shape, 'listMap'),
      Shapes::idx($shape, 'mapMap'),
      Shapes::idx($shape, 'i32WithCustomDefault'),
      Shapes::idx($shape, 'structWithCustomDefault'),
      Shapes::idx($shape, 'structWithFieldCustomDefault'),
    );
  }

  public function getName()[]: string {
    return 'MyStruct';
  }

  public function clearTerseFields()[write_props]: void {
    $this->boolVal = false;
    $this->byteVal = 0;
    $this->i16Val = 0;
    $this->i32Val = 0;
    $this->i64Val = 0;
    $this->floatVal = 0.0;
    $this->doubleVal = 0.0;
    $this->stringVal = '';
    $this->binaryVal = '';
    $this->enumVal = null;
    $this->structVal = null;
    $this->unionVal = null;
    $this->lateStructVal = null;
    $this->listMap = Vector {};
    $this->mapMap = Map {};
    $this->i32WithCustomDefault = 0;
    $this->structWithCustomDefault = null;
    $this->structWithFieldCustomDefault = null;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyStruct",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "boolVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "byteVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "i16Val",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "i32Val",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -5,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "i64Val",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "floatVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -7,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "doubleVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "stringVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -9,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "binaryVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -10,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_enum" => \tmeta_ThriftEnumType::fromShape(
                    shape(
                      "name" => "module.MyEnum",
                    )
                  ),
                )
              ),
              "name" => "enumVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -11,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.MyData",
                    )
                  ),
                )
              ),
              "name" => "structVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -12,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.MyUnion",
                    )
                  ),
                )
              ),
              "name" => "unionVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -13,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.LateDefStruct",
                    )
                  ),
                )
              ),
              "name" => "lateStructVal",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -14,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "optBoolVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -15,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "optByteVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -16,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "optI16Val",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -17,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "optI32Val",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -18,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "optI64Val",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -19,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "optFloatVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -20,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "optDoubleVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -21,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "optStringVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -22,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "optBinaryVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -23,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_enum" => \tmeta_ThriftEnumType::fromShape(
                    shape(
                      "name" => "module.MyEnum",
                    )
                  ),
                )
              ),
              "name" => "optEnumVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -24,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.MyData",
                    )
                  ),
                )
              ),
              "name" => "optStructVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -25,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.LateDefStruct",
                    )
                  ),
                )
              ),
              "name" => "optLateStructVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -26,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optListVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -27,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_set" => \tmeta_ThriftSetType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optSetVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -28,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => \tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "optMapVal",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -29,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => \tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => \tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => \tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "listMap",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -30,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => \tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => \tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => \tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                              "valueType" => \tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "mapMap",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -31,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "i32WithCustomDefault",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -32,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.MyDataWithCustomDefault",
                    )
                  ),
                )
              ),
              "name" => "structWithCustomDefault",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.MyData",
                    )
                  ),
                )
              ),
              "name" => "structWithFieldCustomDefault",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'binaryVal' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Type' => \facebook\thrift\annotation\cpp\Type::fromShape(
              shape(
                "name" => "folly::IOBuf",
              )
            ),
          ],
          'type' => dict[],
        ),
        'optBinaryVal' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Type' => \facebook\thrift\annotation\cpp\Type::fromShape(
              shape(
                "name" => "folly::IOBuf",
              )
            ),
          ],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['boolVal'],
      $shape['byteVal'],
      $shape['i16Val'],
      $shape['i32Val'],
      $shape['i64Val'],
      $shape['floatVal'],
      $shape['doubleVal'],
      $shape['stringVal'],
      $shape['binaryVal'],
      Shapes::idx($shape, 'enumVal'),
      Shapes::idx($shape, 'structVal') |> $$ === null ? null : (\test\fixtures\patch\MyData::__fromShape($$)),
      Shapes::idx($shape, 'unionVal') |> $$ === null ? null : (\test\fixtures\patch\MyUnion::__fromShape($$)),
      Shapes::idx($shape, 'lateStructVal') |> $$ === null ? null : (\test\fixtures\patch\LateDefStruct::__fromShape($$)),
      Shapes::idx($shape, 'optBoolVal'),
      Shapes::idx($shape, 'optByteVal'),
      Shapes::idx($shape, 'optI16Val'),
      Shapes::idx($shape, 'optI32Val'),
      Shapes::idx($shape, 'optI64Val'),
      Shapes::idx($shape, 'optFloatVal'),
      Shapes::idx($shape, 'optDoubleVal'),
      Shapes::idx($shape, 'optStringVal'),
      Shapes::idx($shape, 'optBinaryVal'),
      Shapes::idx($shape, 'optEnumVal'),
      Shapes::idx($shape, 'optStructVal') |> $$ === null ? null : (\test\fixtures\patch\MyData::__fromShape($$)),
      Shapes::idx($shape, 'optLateStructVal') |> $$ === null ? null : (\test\fixtures\patch\LateDefStruct::__fromShape($$)),
      Shapes::idx($shape, 'optListVal') |> $$ === null ? null : ($$ |> new Vector($$)),
      Shapes::idx($shape, 'optSetVal') |> $$ === null ? null : (new Set(Keyset\keys($$))),
      Shapes::idx($shape, 'optMapVal') |> $$ === null ? null : ($$ |> new Map($$)),
      $shape['listMap']
        |> Vec\map(
          $$,
          $_val0 ==> $_val0 |> new Map($$),
        ) |> new Vector($$),
      $shape['mapMap']
        |> Dict\map(
          $$,
          $_val1 ==> $_val1 |> new Map($$),
        ) |> new Map($$),
      $shape['i32WithCustomDefault'],
      Shapes::idx($shape, 'structWithCustomDefault') |> $$ === null ? null : (\test\fixtures\patch\MyDataWithCustomDefault::__fromShape($$)),
      Shapes::idx($shape, 'structWithFieldCustomDefault') |> $$ === null ? null : (\test\fixtures\patch\MyData::__fromShape($$)),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'boolVal' => $this->boolVal,
      'byteVal' => $this->byteVal,
      'i16Val' => $this->i16Val,
      'i32Val' => $this->i32Val,
      'i64Val' => $this->i64Val,
      'floatVal' => $this->floatVal,
      'doubleVal' => $this->doubleVal,
      'stringVal' => $this->stringVal,
      'binaryVal' => $this->binaryVal,
      'enumVal' => $this->enumVal,
      'structVal' => $this->structVal?->__toShape(),
      'unionVal' => $this->unionVal?->__toShape(),
      'lateStructVal' => $this->lateStructVal?->__toShape(),
      'optBoolVal' => $this->optBoolVal,
      'optByteVal' => $this->optByteVal,
      'optI16Val' => $this->optI16Val,
      'optI32Val' => $this->optI32Val,
      'optI64Val' => $this->optI64Val,
      'optFloatVal' => $this->optFloatVal,
      'optDoubleVal' => $this->optDoubleVal,
      'optStringVal' => $this->optStringVal,
      'optBinaryVal' => $this->optBinaryVal,
      'optEnumVal' => $this->optEnumVal,
      'optStructVal' => $this->optStructVal?->__toShape(),
      'optLateStructVal' => $this->optLateStructVal?->__toShape(),
      'optListVal' => $this->optListVal
        |> $$ === null ? null : vec($$),
      'optSetVal' => $this->optSetVal
        |> $$ === null ? null : ThriftUtil::toDArray(Dict\fill_keys($$->toValuesArray(), true), static::class),
      'optMapVal' => $this->optMapVal
        |> $$ === null ? null : dict($$),
      'listMap' => $this->listMap->map(
        ($_val0) ==> dict($_val0),
      )
        |> vec($$),
      'mapMap' => $this->mapMap->map(
        ($_val0) ==> dict($_val0),
      )
        |> dict($$),
      'i32WithCustomDefault' => $this->i32WithCustomDefault,
      'structWithCustomDefault' => $this->structWithCustomDefault?->__toShape(),
      'structWithFieldCustomDefault' => $this->structWithFieldCustomDefault?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'boolVal') !== null) {
      $this->boolVal = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['boolVal']);
    }
    if (idx($parsed, 'byteVal') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['byteVal']);
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->byteVal = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'i16Val') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i16Val']);
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i16Val = (int)$_tmp1;
      }
    }
    if (idx($parsed, 'i32Val') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i32Val']);
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32Val = (int)$_tmp2;
      }
    }
    if (idx($parsed, 'i64Val') !== null) {
      $this->i64Val = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i64Val']);
    }
    if (idx($parsed, 'floatVal') !== null) {
      $this->floatVal = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['floatVal']);
    }
    if (idx($parsed, 'doubleVal') !== null) {
      $this->doubleVal = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['doubleVal']);
    }
    if (idx($parsed, 'stringVal') !== null) {
      $this->stringVal = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['stringVal']);
    }
    if (idx($parsed, 'binaryVal') !== null) {
      $this->binaryVal = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['binaryVal']);
    }
    if (idx($parsed, 'enumVal') !== null) {
      $this->enumVal = \test\fixtures\patch\MyEnum::coerce(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyEnum>($parsed['enumVal']));
    }
    if (idx($parsed, 'structVal') !== null) {
      $_tmp3 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyData>($parsed['structVal']));
      $_tmp4 = \test\fixtures\patch\MyData::withDefaultValues();
      $_tmp4->readFromJson($_tmp3);
      $this->structVal = $_tmp4;
    }
    if (idx($parsed, 'unionVal') !== null) {
      $_tmp5 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyUnion>($parsed['unionVal']));
      $_tmp6 = \test\fixtures\patch\MyUnion::withDefaultValues();
      $_tmp6->readFromJson($_tmp5);
      $this->unionVal = $_tmp6;
    }
    if (idx($parsed, 'lateStructVal') !== null) {
      $_tmp7 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\LateDefStruct>($parsed['lateStructVal']));
      $_tmp8 = \test\fixtures\patch\LateDefStruct::withDefaultValues();
      $_tmp8->readFromJson($_tmp7);
      $this->lateStructVal = $_tmp8;
    }
    if (idx($parsed, 'optBoolVal') !== null) {
      $this->optBoolVal = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['optBoolVal']);
    }
    if (idx($parsed, 'optByteVal') !== null) {
      $_tmp9 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['optByteVal']);
      if ($_tmp9 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->optByteVal = (int)$_tmp9;
      }
    }
    if (idx($parsed, 'optI16Val') !== null) {
      $_tmp10 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['optI16Val']);
      if ($_tmp10 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->optI16Val = (int)$_tmp10;
      }
    }
    if (idx($parsed, 'optI32Val') !== null) {
      $_tmp11 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['optI32Val']);
      if ($_tmp11 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->optI32Val = (int)$_tmp11;
      }
    }
    if (idx($parsed, 'optI64Val') !== null) {
      $this->optI64Val = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['optI64Val']);
    }
    if (idx($parsed, 'optFloatVal') !== null) {
      $this->optFloatVal = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['optFloatVal']);
    }
    if (idx($parsed, 'optDoubleVal') !== null) {
      $this->optDoubleVal = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['optDoubleVal']);
    }
    if (idx($parsed, 'optStringVal') !== null) {
      $this->optStringVal = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['optStringVal']);
    }
    if (idx($parsed, 'optBinaryVal') !== null) {
      $this->optBinaryVal = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['optBinaryVal']);
    }
    if (idx($parsed, 'optEnumVal') !== null) {
      $this->optEnumVal = \test\fixtures\patch\MyEnum::coerce(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyEnum>($parsed['optEnumVal']));
    }
    if (idx($parsed, 'optStructVal') !== null) {
      $_tmp12 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyData>($parsed['optStructVal']));
      $_tmp13 = \test\fixtures\patch\MyData::withDefaultValues();
      $_tmp13->readFromJson($_tmp12);
      $this->optStructVal = $_tmp13;
    }
    if (idx($parsed, 'optLateStructVal') !== null) {
      $_tmp14 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\LateDefStruct>($parsed['optLateStructVal']));
      $_tmp15 = \test\fixtures\patch\LateDefStruct::withDefaultValues();
      $_tmp15->readFromJson($_tmp14);
      $this->optLateStructVal = $_tmp15;
    }
    if (idx($parsed, 'optListVal') !== null) {
      $_json19 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['optListVal']);
      $_container20 = Vector {};
      foreach($_json19 as $_key17 => $_value18) {
        $_elem21 = 0;
        $_tmp22 = (int)$_value18;
        if ($_tmp22 > 0x7fff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem21 = (int)$_tmp22;
        }
        $_container20 []= $_elem21;
      }
      $this->optListVal = $_container20;
    }
    if (idx($parsed, 'optSetVal') !== null) {
      $_json26 = HH\FIXME\UNSAFE_CAST<mixed, Set<string>>($parsed['optSetVal']);
      $_container27 = Set {};
      foreach($_json26 as $_key24 => $_value25) {
        $_elem28 = '';
        $_elem28 = $_value25;
        $_container27->add($_elem28);
      }
      $this->optSetVal = $_container27;
    }
    if (idx($parsed, 'optMapVal') !== null) {
      $_json32 = HH\FIXME\UNSAFE_CAST<mixed, Map<string, string>>($parsed['optMapVal']);
      $_container33 = Map {};
      foreach($_json32 as $_key30 => $_value31) {
        $_value34 = '';
        $_value34 = $_value31;
        $_container33[$_key30] = $_value34;
      }
      $this->optMapVal = $_container33;
    }
    if (idx($parsed, 'listMap') !== null) {
      $_json38 = HH\FIXME\UNSAFE_CAST<mixed, Vector<Map<string, int>>>($parsed['listMap']);
      $_container39 = Vector {};
      foreach($_json38 as $_key36 => $_value37) {
        $_elem40 = Map {};
        $_json44 = $_value37;
        $_container45 = Map {};
        foreach($_json44 as $_key42 => $_value43) {
          $_value46 = 0;
          $_tmp47 = (int)$_value43;
          if ($_tmp47 > 0x7fffffff) {
            throw new \TProtocolException("number exceeds limit in field");
          } else {
            $_value46 = (int)$_tmp47;
          }
          $_container45[$_key42] = $_value46;
        }
        $_elem40 = $_container45;
        $_container39 []= $_elem40;
      }
      $this->listMap = $_container39;
    }
    if (idx($parsed, 'mapMap') !== null) {
      $_json51 = HH\FIXME\UNSAFE_CAST<mixed, Map<string, Map<string, int>>>($parsed['mapMap']);
      $_container52 = Map {};
      foreach($_json51 as $_key49 => $_value50) {
        $_value53 = Map {};
        $_json57 = $_value50;
        $_container58 = Map {};
        foreach($_json57 as $_key55 => $_value56) {
          $_value59 = 0;
          $_tmp60 = (int)$_value56;
          if ($_tmp60 > 0x7fffffff) {
            throw new \TProtocolException("number exceeds limit in field");
          } else {
            $_value59 = (int)$_tmp60;
          }
          $_container58[$_key55] = $_value59;
        }
        $_value53 = $_container58;
        $_container52[$_key49] = $_value53;
      }
      $this->mapMap = $_container52;
    }
    if (idx($parsed, 'i32WithCustomDefault') !== null) {
      $_tmp61 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i32WithCustomDefault']);
      if ($_tmp61 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32WithCustomDefault = (int)$_tmp61;
      }
    }
    if (idx($parsed, 'structWithCustomDefault') !== null) {
      $_tmp62 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyDataWithCustomDefault>($parsed['structWithCustomDefault']));
      $_tmp63 = \test\fixtures\patch\MyDataWithCustomDefault::withDefaultValues();
      $_tmp63->readFromJson($_tmp62);
      $this->structWithCustomDefault = $_tmp63;
    }
    if (idx($parsed, 'structWithFieldCustomDefault') !== null) {
      $_tmp64 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\MyData>($parsed['structWithFieldCustomDefault']));
      $_tmp65 = \test\fixtures\patch\MyData::withDefaultValues();
      $_tmp65->readFromJson($_tmp64);
      $this->structWithFieldCustomDefault = $_tmp65;
    }
  }

}

/**
 * Original thrift struct:-
 * LateDefStruct
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/LateDefStruct'))>>
class LateDefStruct implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
    ...
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'LateDefStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.LateDefStruct",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * Recursive
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/Recursive'))>>
class Recursive implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    -1 => shape(
      'var' => 'nodes',
      'is_terse' => true,
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => \test\fixtures\patch\Recursive::class,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'nodes' => -1,
  ];

  const type TConstructorShape = shape(
    ?'nodes' => ?Map<string, \test\fixtures\patch\Recursive>,
  );

  const type TShape = shape(
    'nodes' => dict<string, \test\fixtures\patch\Recursive::TShape>,
    ...
  );
  const int STRUCTURAL_ID = 6832467362236085104;
  /**
   * Original thrift field:-
   * -1: map<string, module.Recursive> nodes
   */
  public Map<string, \test\fixtures\patch\Recursive> $nodes;

  public function __construct(?Map<string, \test\fixtures\patch\Recursive> $nodes = null)[] {
    $this->nodes = $nodes ?? Map {};
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'nodes'),
    );
  }

  public function getName()[]: string {
    return 'Recursive';
  }

  public function clearTerseFields()[write_props]: void {
    $this->nodes = Map {};
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.Recursive",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => \tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => \tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "module.Recursive",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "nodes",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'nodes' => shape(
          'field' => dict[
            '\facebook\thrift\op\AssignOnlyPatch' => \facebook\thrift\op\AssignOnlyPatch::fromShape(
              shape(
              )
            ),
          ],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['nodes']
        |> Dict\map(
          $$,
          $_val0 ==> $_val0
            |> \test\fixtures\patch\Recursive::__fromShape($$),
        ) |> new Map($$),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'nodes' => $this->nodes->map(
        ($_val0) ==> $_val0->__toShape(),
      )
        |> dict($$),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'nodes') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Map<string, \test\fixtures\patch\Recursive>>($parsed['nodes']);
      $_container4 = Map {};
      foreach($_json3 as $_key1 => $_value2) {
        $_value5 = \test\fixtures\patch\Recursive::withDefaultValues();
        $_tmp6 = \json_encode($_value2);
        $_tmp7 = \test\fixtures\patch\Recursive::withDefaultValues();
        $_tmp7->readFromJson($_tmp6);
        $_value5 = $_tmp7;
        $_container4[$_key1] = $_value5;
      }
      $this->nodes = $_container4;
    }
  }

}

/**
 * Original thrift struct:-
 * Bar
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/Bar'))>>
class Bar implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    -1 => shape(
      'var' => 'loop',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\Loop::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'loop' => -1,
  ];

  const type TConstructorShape = shape(
    ?'loop' => ?\test\fixtures\patch\Loop,
  );

  const type TShape = shape(
    ?'loop' => ?\test\fixtures\patch\Loop::TShape,
    ...
  );
  const int STRUCTURAL_ID = 418974100266768802;
  /**
   * Original thrift field:-
   * -1: module.Loop loop
   */
  public ?\test\fixtures\patch\Loop $loop;

  public function __construct(?\test\fixtures\patch\Loop $loop = null)[] {
    $this->loop = $loop;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'loop'),
    );
  }

  public function getName()[]: string {
    return 'Bar';
  }

  public function clearTerseFields()[write_props]: void {
    $this->loop = null;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.Bar",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.Loop",
                    )
                  ),
                )
              ),
              "name" => "loop",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'loop' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::Unique,
              )
            ),
          ],
          'type' => dict[
            '\facebook\thrift\op\AssignOnlyPatch' => \facebook\thrift\op\AssignOnlyPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'loop') |> $$ === null ? null : (\test\fixtures\patch\Loop::__fromShape($$)),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'loop' => $this->loop?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'loop') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\Loop>($parsed['loop']));
      $_tmp1 = \test\fixtures\patch\Loop::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->loop = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * Loop
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/Loop'))>>
class Loop implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    -1 => shape(
      'var' => 'bar',
      'is_terse' => true,
      'type' => \TType::STRUCT,
      'class' => \test\fixtures\patch\Bar::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'bar' => -1,
  ];

  const type TConstructorShape = shape(
    ?'bar' => ?\test\fixtures\patch\Bar,
  );

  const type TShape = shape(
    ?'bar' => ?\test\fixtures\patch\Bar::TShape,
    ...
  );
  const int STRUCTURAL_ID = 3942468431999341434;
  /**
   * Original thrift field:-
   * -1: module.Bar bar
   */
  public ?\test\fixtures\patch\Bar $bar;

  public function __construct(?\test\fixtures\patch\Bar $bar = null)[] {
    $this->bar = $bar;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'bar'),
    );
  }

  public function getName()[]: string {
    return 'Loop';
  }

  public function clearTerseFields()[write_props]: void {
    $this->bar = null;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.Loop",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => -1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.Bar",
                    )
                  ),
                )
              ),
              "name" => "bar",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\op\AssignOnlyPatch' => \facebook\thrift\op\AssignOnlyPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
        'bar' => shape(
          'field' => dict[
            '\facebook\thrift\op\AssignOnlyPatch' => \facebook\thrift\op\AssignOnlyPatch::fromShape(
              shape(
              )
            ),
          ],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'bar') |> $$ === null ? null : (\test\fixtures\patch\Bar::__fromShape($$)),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'bar' => $this->bar?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'bar') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \test\fixtures\patch\Bar>($parsed['bar']));
      $_tmp1 = \test\fixtures\patch\Bar::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->bar = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * RefFields
 */
<<\ThriftTypeInfo(shape('uri' => 'test.dev/fixtures/patch/RefFields'))>>
class RefFields implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct, \IThriftStructWithClearTerseFields {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'unique',
      'is_terse' => true,
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'shared_const',
      'is_terse' => true,
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'shared_mustable',
      'is_terse' => true,
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'opt_unique',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'opt_shared_const',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'opt_shared_mustable',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    7 => shape(
      'var' => 'opt_box',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'unique' => 1,
    'shared_const' => 2,
    'shared_mustable' => 3,
    'opt_unique' => 4,
    'opt_shared_const' => 5,
    'opt_shared_mustable' => 6,
    'opt_box' => 7,
  ];

  const type TConstructorShape = shape(
    ?'unique' => ?Vector<int>,
    ?'shared_const' => ?Vector<int>,
    ?'shared_mustable' => ?Vector<int>,
    ?'opt_unique' => ?Vector<int>,
    ?'opt_shared_const' => ?Vector<int>,
    ?'opt_shared_mustable' => ?Vector<int>,
    ?'opt_box' => ?Vector<int>,
  );

  const type TShape = shape(
    'unique' => vec<int>,
    'shared_const' => vec<int>,
    'shared_mustable' => vec<int>,
    ?'opt_unique' => ?vec<int>,
    ?'opt_shared_const' => ?vec<int>,
    ?'opt_shared_mustable' => ?vec<int>,
    ?'opt_box' => ?vec<int>,
    ...
  );
  const int STRUCTURAL_ID = 7082271269182165768;
  /**
   * Original thrift field:-
   * 1: list<i32> unique
   */
  public Vector<int> $unique;
  /**
   * Original thrift field:-
   * 2: list<i32> shared_const
   */
  public Vector<int> $shared_const;
  /**
   * Original thrift field:-
   * 3: list<i32> shared_mustable
   */
  public Vector<int> $shared_mustable;
  /**
   * Original thrift field:-
   * 4: list<i32> opt_unique
   */
  public ?Vector<int> $opt_unique;
  /**
   * Original thrift field:-
   * 5: list<i32> opt_shared_const
   */
  public ?Vector<int> $opt_shared_const;
  /**
   * Original thrift field:-
   * 6: list<i32> opt_shared_mustable
   */
  public ?Vector<int> $opt_shared_mustable;
  /**
   * Original thrift field:-
   * 7: list<i32> opt_box
   */
  public ?Vector<int> $opt_box;

  public function __construct(?Vector<int> $unique = null, ?Vector<int> $shared_const = null, ?Vector<int> $shared_mustable = null, ?Vector<int> $opt_unique = null, ?Vector<int> $opt_shared_const = null, ?Vector<int> $opt_shared_mustable = null, ?Vector<int> $opt_box = null)[] {
    $this->unique = $unique ?? Vector {};
    $this->shared_const = $shared_const ?? Vector {};
    $this->shared_mustable = $shared_mustable ?? Vector {};
    $this->opt_unique = $opt_unique;
    $this->opt_shared_const = $opt_shared_const;
    $this->opt_shared_mustable = $opt_shared_mustable;
    $this->opt_box = $opt_box;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'unique'),
      Shapes::idx($shape, 'shared_const'),
      Shapes::idx($shape, 'shared_mustable'),
      Shapes::idx($shape, 'opt_unique'),
      Shapes::idx($shape, 'opt_shared_const'),
      Shapes::idx($shape, 'opt_shared_mustable'),
      Shapes::idx($shape, 'opt_box'),
    );
  }

  public function getName()[]: string {
    return 'RefFields';
  }

  public function clearTerseFields()[write_props]: void {
    $this->unique = Vector {};
    $this->shared_const = Vector {};
    $this->shared_mustable = Vector {};
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.RefFields",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "unique",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "shared_const",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "shared_mustable",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "opt_unique",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "opt_shared_const",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "opt_shared_mustable",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => \tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => \tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "opt_box",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'unique' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::Unique,
              )
            ),
          ],
          'type' => dict[],
        ),
        'shared_const' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::Shared,
              )
            ),
          ],
          'type' => dict[],
        ),
        'shared_mustable' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::SharedMutable,
              )
            ),
          ],
          'type' => dict[],
        ),
        'opt_unique' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::Unique,
              )
            ),
          ],
          'type' => dict[],
        ),
        'opt_shared_const' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::Shared,
              )
            ),
          ],
          'type' => dict[],
        ),
        'opt_shared_mustable' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\cpp\Ref' => \facebook\thrift\annotation\cpp\Ref::fromShape(
              shape(
                "type" => \facebook\thrift\annotation\cpp\RefType::SharedMutable,
              )
            ),
          ],
          'type' => dict[],
        ),
        'opt_box' => shape(
          'field' => dict[
            '\facebook\thrift\annotation\Box' => \facebook\thrift\annotation\Box::fromShape(
              shape(
              )
            ),
          ],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['unique'] |> new Vector($$),
      $shape['shared_const'] |> new Vector($$),
      $shape['shared_mustable'] |> new Vector($$),
      Shapes::idx($shape, 'opt_unique') |> $$ === null ? null : ($$ |> new Vector($$)),
      Shapes::idx($shape, 'opt_shared_const') |> $$ === null ? null : ($$ |> new Vector($$)),
      Shapes::idx($shape, 'opt_shared_mustable') |> $$ === null ? null : ($$ |> new Vector($$)),
      Shapes::idx($shape, 'opt_box') |> $$ === null ? null : ($$ |> new Vector($$)),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'unique' => vec($this->unique),
      'shared_const' => vec($this->shared_const),
      'shared_mustable' => vec($this->shared_mustable),
      'opt_unique' => $this->opt_unique
        |> $$ === null ? null : vec($$),
      'opt_shared_const' => $this->opt_shared_const
        |> $$ === null ? null : vec($$),
      'opt_shared_mustable' => $this->opt_shared_mustable
        |> $$ === null ? null : vec($$),
      'opt_box' => $this->opt_box
        |> $$ === null ? null : vec($$),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'unique') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['unique']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->unique = $_container4;
    }
    if (idx($parsed, 'shared_const') !== null) {
      $_json10 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['shared_const']);
      $_container11 = Vector {};
      foreach($_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11 []= $_elem12;
      }
      $this->shared_const = $_container11;
    }
    if (idx($parsed, 'shared_mustable') !== null) {
      $_json17 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['shared_mustable']);
      $_container18 = Vector {};
      foreach($_json17 as $_key15 => $_value16) {
        $_elem19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem19 = (int)$_tmp20;
        }
        $_container18 []= $_elem19;
      }
      $this->shared_mustable = $_container18;
    }
    if (idx($parsed, 'opt_unique') !== null) {
      $_json24 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['opt_unique']);
      $_container25 = Vector {};
      foreach($_json24 as $_key22 => $_value23) {
        $_elem26 = 0;
        $_tmp27 = (int)$_value23;
        if ($_tmp27 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem26 = (int)$_tmp27;
        }
        $_container25 []= $_elem26;
      }
      $this->opt_unique = $_container25;
    }
    if (idx($parsed, 'opt_shared_const') !== null) {
      $_json31 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['opt_shared_const']);
      $_container32 = Vector {};
      foreach($_json31 as $_key29 => $_value30) {
        $_elem33 = 0;
        $_tmp34 = (int)$_value30;
        if ($_tmp34 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem33 = (int)$_tmp34;
        }
        $_container32 []= $_elem33;
      }
      $this->opt_shared_const = $_container32;
    }
    if (idx($parsed, 'opt_shared_mustable') !== null) {
      $_json38 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['opt_shared_mustable']);
      $_container39 = Vector {};
      foreach($_json38 as $_key36 => $_value37) {
        $_elem40 = 0;
        $_tmp41 = (int)$_value37;
        if ($_tmp41 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem40 = (int)$_tmp41;
        }
        $_container39 []= $_elem40;
      }
      $this->opt_shared_mustable = $_container39;
    }
    if (idx($parsed, 'opt_box') !== null) {
      $_json45 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['opt_box']);
      $_container46 = Vector {};
      foreach($_json45 as $_key43 => $_value44) {
        $_elem47 = 0;
        $_tmp48 = (int)$_value44;
        if ($_tmp48 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem47 = (int)$_tmp48;
        }
        $_container46 []= $_elem47;
      }
      $this->opt_box = $_container46;
    }
  }

}

